# A store sells apples at $5 each and bananas at $3 each. Declare variables apples_price and bananas_price with appropriate values. 
Calculate the total cost for purchasing 10 apples and 7 bananas and store the result in total_cost. 

USE PYTEST FRAMEWORK

This is calculate_py
apple_price=5
banana_price=3

def calculate_total_cost(apple_count,banana_count):
    return (apple_price*apple_count + banana_price*banana_count)
    
    
#Create one more file called test using pytest
import pytest

def test_calculate_total_cost():
    
    assert calculate_total_cost(1,1) == 8
    

The function to calcualte the total cost is in seperate file. The test cases are written in seperate file. We use pytest because pytest framework allows to add as many test cases in future. 

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Method 1A: Using exceptions and not using any decorators:

# enter apple price and its count. Enter banana count and its price. calculate the total price

class NoValueError(Exception):
    pass

class CustomValueError(Exception):
    pass


def calculate_price(apple_count,apple_price,banana_count,banana_price):
    
    try:
        
        if not isinstance(apple_count,(int,float)) or not isinstance(banana_count,(int,float)):
            raise ValueError("The count should be always int or float")
            
        if not isinstance(apple_price,(int,float)) or not isinstance(banana_price,(int,float)):
            
            raise ValueError("The count should be always int or float")
            
        if (apple_count or banana_count) <= 0:
            raise CustomValueError("Value cannot be negative")
            
        if (apple_price or banana_price) <=0:
            raise CustomValueError("Value cannot be negative")
            
        # if apple_count isinstance:
        #     print("Cannot be empty")
        
        return apple_count *apple_price + banana_count * banana_price
        
    except Exception as e:
        print(e)
        return None
        
    finally:
        print(" ")

for i in range(1):
    
    try:
        apple_count=int(input("Enter apple count"))
        apple_price=int(input("Enter apple price"))
        banana_count=int(input("Enter banana count"))
        banana_price=int(input("Enter banana price"))
        total_price=calculate_price(apple_count,apple_price,banana_count,banana_price)
    
        if total_price is not None:
            print(int(total_price))
    
        else:
            print("Invalid input, can't calculate")
    except Exception as e:
        print("Invalid input!")
       
    
-------------------------------------------------------------------------------------------------
Method 1B: Using exceptions and decorators but not with a*args and **kwargs:
# enter apple price and its count. Enter banana count and its price. calculate the total price

class NoValueError(Exception):
    pass

class CustomValueError(Exception):
    pass


def deco_calculate_price(func):
    
    def wrapper(apple_count,apple_price,banana_count,banana_price):
        try:
            if not isinstance(apple_count,(int,float)) or not isinstance(banana_count,(int,float)):
                raise ValueError("The count should be always int or float")
            
            if not isinstance(apple_price,(int,float)) or not isinstance(banana_price,(int,float)):
                raise ValueError("The count should be always int or float")
            
            if (apple_count or banana_count) <= 0:
                raise CustomValueError("Value cannot be negative")
            
            if (apple_price or banana_price) <=0:
                raise CustomValueError("Value cannot be negative")
            
            if not apple_count:
                print("apple count cannot be empty")
                
            if not apple_price:
                print("apple price cannot be empty")
                
            if not banana_count:
                print("banana count cannot be empty")
                
            if not banana_price:
                print("banana price cannot be empty")
        
            
        
        except Exception as e:
            print(e)
            return None
        
        finally:
            print(" ")
            
            return func(apple_count,apple_price,banana_count,banana_price)
    return wrapper

@deco_calculate_price
def calculate_price(func):
    
    return apple_count*apple_price + banana_count*banana_price
    
for i in range(4):
    try:
        apple_count=int(input("Enter apple count"))
        apple_price=int(input("Enter apple price"))
        banana_count=int(input("Enter banana count"))
        banana_price=int(input("Enter banana price"))
            
        total_price=apple_count*apple_price + banana_count*banana_price
       
       
        if total_price is not None:
            print(int(total_price))
    
        else:
            print("Invalid input, can't calculate")
                
    except Exception as e:
        print("Invalid input!")
       
    

---------------------------------------------------------------------------------------------------------------------------
method 2:

apple_price=int(input("Enter the apple price"))
apple_count=int(input("Enter the apple count"))
banana_price=int(input("Enter the banana price"))
banana_count=int(input("Enter the banana count"))

def total_cost(apple_count,banana_count):
    return apple_price*apple_count+banana_price*banana_count
    
print("Total cost is-->",apple_price*apple_count+banana_price*banana_count)

----------------------------------------------------------------------------------------------------------------------
method 3: using decorators and *argrs and **kwargs
# enter apple price and its count. Enter banana count and its price. calculate the total price

class NoValueError(Exception):
    pass

class CustomValueError(Exception):
    pass


def deco_calculate_price(func):
    
    def wrapper(*args,**kwargs):
        try:
            if not isinstance(apple_count,(int,float)) or not isinstance(banana_count,(int,float)):
                raise ValueError("The count should be always int or float")
            
            if not isinstance(apple_price,(int,float)) or not isinstance(banana_price,(int,float)):
                raise ValueError("The count should be always int or float")
            
            if (apple_count or banana_count) <= 0:
                raise CustomValueError("Value cannot be negative")
            
            if (apple_price or banana_price) <=0:
                raise CustomValueError("Value cannot be negative")
            
            if not apple_count:
                print("apple count cannot be empty")
                
            if not apple_price:
                print("apple price cannot be empty")
                
            if not banana_count:
                print("banana count cannot be empty")
                
            if not banana_price:
                print("banana price cannot be empty")
        
            
        
        except Exception as e:
            print(e)
            return None
        
        finally:
            print(" ")
            
            return func(*args,**kwargs)
    return wrapper

@deco_calculate_price
def calculate_price(func):
    
    return apple_count*apple_price + banana_count*banana_price
    
for i in range(4):
    try:
        apple_count=int(input("Enter apple count"))
        apple_price=int(input("Enter apple price"))
        banana_count=int(input("Enter banana count"))
        banana_price=int(input("Enter banana price"))
            
        total_price=apple_count*apple_price + banana_count*banana_price
       
       
        if total_price is not None:
            print(int(total_price))
    
        else:
            print("Invalid input, can't calculate")
                
    except Exception as e:
        print("Invalid input!")
       
    
)
--------------------------------------------------------------------------------------------------------------
method 4: using only *args ie only positional argument

apple_price=int(input("Enter apple price"))
banana_price=int(input("Enter banana price"))
apple_count=int(input("Enter apple count"))
banana_count=int(input("Enter banana count"))

def deco(func):
    def wrapper(*args):
        return func(*args)
        print("Before wrapper")
    return wrapper
    
@deco
def total_cost(apple_count,banana_count):
    return apple_price*apple_count +banana_price*banana_count
    
total_cost(apple_count,banana_count)

print("The total cost is", total_cost(apple_count,banana_count))
---------------------------------------------------------------------------------------------------------
method 5: using only **kwargs ie only keyword arguments


apple_price=int(input("Enter apple price"))
banana_price=int(input("Enter banana price"))
apple_count=int(input("Enter apple count"))
banana_count=int(input("Enter banana count"))

def deco(func):
    def wrapper(**kwargs):
        return func(**kwargs)
        print("Before wrapper")
    return wrapper
    
@deco
def total_cost(**kwargs):
    apple_count=kwargs.get("apple_count",0)
    banana_count=kwargs.get("banana_count",0)
    return apple_price*apple_count +banana_price*banana_count


print("The total cost is", apple_price*apple_count +banana_price*banana_count)



Donâ€™t worry! Let me break it down step by step in the simplest way:

Why does *args work differently?
*args collects all positional arguments as a tuple. So when you pass total_cost(2, 3), Python automatically puts 2 and 3 into a tuple like this: (2, 3).

Then, you can pass these values directly to your function using func(*args), and it will "unpack" the tuple into the correct positions for apple_count and banana_count.

Why do we use .get() for **kwargs?
**kwargs collects all keyword arguments as a dictionary. So when you pass total_cost(apple_count=2, banana_count=3), Python creates a dictionary like this: {'apple_count': 2, 'banana_count': 3}.

To get values from a dictionary, you need to look them up using keys like kwargs['apple_count'].

But if a key doesn't exist, Python will throw an error.
To avoid this, we use kwargs.get("key", default_value) which:
Finds the value of the key (e.g., kwargs.get("apple_count") gives 2).
Returns a default value (like 0) if the key is missing.
So, for **kwargs, you use .get() to safely extract the values you need.




