# A store sells apples at $5 each and bananas at $3 each. Declare variables apples_price and bananas_price with appropriate values. 
Calculate the total cost for purchasing 10 apples and 7 bananas and store the result in total_cost. 

USE PYTEST FRAMEWORK

This is calculate_py
apple_price=5
banana_price=3

def calculate_total_cost(apple_count,banana_count):
    return (apple_price*apple_count + banana_price*banana_count)
    
    
#Create one more file called test using pytest
import pytest

def test_calculate_total_cost():
    
    assert calculate_total_cost(1,1) == 8
    

The function to calcualte the total cost is in seperate file. The test cases are written in seperate file. We use pytest because pytest framework allows to add as many test cases in future. 

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method 2:

apple_price=int(input("Enter the apple price"))
apple_count=int(input("Enter the apple count"))
banana_price=int(input("Enter the banana price"))
banana_count=int(input("Enter the banana count"))

def total_cost(apple_count,banana_count):
    return apple_price*apple_count+banana_price*banana_count
    
print("Total cost is-->",apple_price*apple_count+banana_price*banana_count)

----------------------------------------------------------------------------------------------------------------------
method 3: using decorators and *argrs and **kwargs
apple_price=int(input("Enter apple price"))
banana_price=int(input("Enter banana price"))
apple_count=int(input("Enter apple count"))
banana_count=int(input("Enter banana count"))

def deco(func):
    def wrapper(*args,**kwargs):
        return func(*args,**kwargs)
        print("Before wrapper")
    return wrapper
    
@deco
def total_cost(apple_count,banana_count): //YOU CAN ALSO USE def total_cost(*args, **kwargs)
    return apple_price*apple_count +banana_price*banana_count
    
total_cost(apple_count,banana_count)

print("The total cost is", total_cost(apple_count,banana_count))
--------------------------------------------------------------------------------------------------------------
method 4: using only *args ie only positional argument

apple_price=int(input("Enter apple price"))
banana_price=int(input("Enter banana price"))
apple_count=int(input("Enter apple count"))
banana_count=int(input("Enter banana count"))

def deco(func):
    def wrapper(*args):
        return func(*args)
        print("Before wrapper")
    return wrapper
    
@deco
def total_cost(apple_count,banana_count):
    return apple_price*apple_count +banana_price*banana_count
    
total_cost(apple_count,banana_count)

print("The total cost is", total_cost(apple_count,banana_count))
---------------------------------------------------------------------------------------------------------
method 5: using only **kwargs ie only keyword arguments


apple_price=int(input("Enter apple price"))
banana_price=int(input("Enter banana price"))
apple_count=int(input("Enter apple count"))
banana_count=int(input("Enter banana count"))

def deco(func):
    def wrapper(**kwargs):
        return func(**kwargs)
        print("Before wrapper")
    return wrapper
    
@deco
def total_cost(**kwargs):
    apple_count=kwargs.get("apple_count",0)
    banana_count=kwargs.get("banana_count",0)
    return apple_price*apple_count +banana_price*banana_count


print("The total cost is", apple_price*apple_count +banana_price*banana_count)



Donâ€™t worry! Let me break it down step by step in the simplest way:

Why does *args work differently?
*args collects all positional arguments as a tuple. So when you pass total_cost(2, 3), Python automatically puts 2 and 3 into a tuple like this: (2, 3).

Then, you can pass these values directly to your function using func(*args), and it will "unpack" the tuple into the correct positions for apple_count and banana_count.

Why do we use .get() for **kwargs?
**kwargs collects all keyword arguments as a dictionary. So when you pass total_cost(apple_count=2, banana_count=3), Python creates a dictionary like this: {'apple_count': 2, 'banana_count': 3}.

To get values from a dictionary, you need to look them up using keys like kwargs['apple_count'].

But if a key doesn't exist, Python will throw an error.
To avoid this, we use kwargs.get("key", default_value) which:
Finds the value of the key (e.g., kwargs.get("apple_count") gives 2).
Returns a default value (like 0) if the key is missing.
So, for **kwargs, you use .get() to safely extract the values you need.




