You have a monthly salary of $4,000 and expenses that include rent ($1,200), groceries ($300), and miscellaneous ($500). Calculate the amount left after expenses and store it in a variable named remaining_balance.

Method1:  Using a for loop
salary = 4000
expenses = [1200, 300, 500]

remaining_balance = salary
for expense in expenses:
    remaining_balance -= expense

print("Remaining balance using for loop:", remaining_balance)

------------------------------------

Method 1A - using function:

def calculate_balance(salary, expense):
    balance = salary
    for i in expense:
        balance -= i
    return balance

salary = 9000
expense = [900, 900]

balance = calculate_balance(salary, expense)
print(int(balance))


------------------------------------------------------------------------

Method 1B: 
def some_func(salary,expenses):
    
    balance=salary
    for expense in expenses:
        balance-= expense
        
    return balance
    
salary_input=int(input("Enter salary"))
expenses_input=input("Enter expenses")
expenses=map(int,expenses_input.split(","))

total=some_func(salary_input,expenses)
print(int(total))

-------------------------------------------------------------------------------
Method 1c: Exceptions:
class NoValueError(Exception):
    pass

class NotAStringError(Exception):
    pass

class EmptyStringError(Exception):
    pass

def some_func(salary,expenses):
    
    try:
        
        if not isinstance(salary,(int,float)):
            raise NotAStringError("Please enter salary in numericals or flaot")
            
        if salary <= 0:
            raise EmptyStringError("salary cannot be zero")
        
        if not expenses:
            raise NoValueError("Expenses cannot be empty")
            
        if any(expense > salary for expense in expenses):
            raise ValueError("Expenses cannot be greater than salary")
            
        balance=salary  
        for expense in expenses:
            balance-= expense
        
        return balance
    
    except Exception as e:
        print(e)
        return None
        
    finally:
        print("balance calc is done")
        
        
try:
    for i in range(3):
        salary_input=int(input("Enter salary"))

        expenses_input=input("Enter expenses")

        expenses=list(map(int,expenses_input.split(",")))

        total=some_func(salary_input,expenses)
        if total is not None:
            print(int(total))
except:
    print("invlaid input")
------------------------------------------------------------------------------------------------------
Method 2: Using decorators without *args and **kwargs

# Using decorators with no *args or **kwargs
def calculate_decorator_simple(func):
    def wrapper(salary, expenses):
        try:
            return func(salary, expenses)
        except Exception as e:
            print(f"An error occurred: {e}")
            return None
    return wrapper

@calculate_decorator_simple
def calculate_remaining_balance_simple(salary, expenses):
    return salary - sum(expenses)

remaining_balance = calculate_remaining_balance_simple(4000, [1200, 300, 500])
print("Remaining balance with no *args/**kwargs decorator:", remaining_balance)

------------------------------
Method 3:   Using a decorator with both *args and **kwargs

# Using decorators with *args and **kwargs
def calculate_decorator_all(func):
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except Exception as e:
            print(f"An error occurred: {e}")
            return None
    return wrapper

@calculate_decorator_all
def calculate_remaining_balance_all(salary, *expenses, **details):
    total_expenses = sum(expenses) + sum(details.values())
    return salary - total_expenses

remaining_balance = calculate_remaining_balance_all(4000, 300, rent=1200, miscellaneous=500)
print("Remaining balance using *args and **kwargs decorator:", remaining_balance)

OR

def decorator_sum(func):
    def wrapper(*args, **kwargs):
        # Extract salary and expenses logic here
        salary = args[0]  # First positional argument is salary
        expenses = args[1]  # Second positional argument is a list of expenses
        
        # Calculate total expense
        total_expense = sum(expenses)
        
        # Pass processed arguments to the original function
        return func(salary, total_expense)
    return wrapper

@decorator_sum
def some_func(salary, total_expense):
    return salary - total_expense  # Subtract total expenses from salary

# Pass salary and expenses
remaining_bal = some_func(10000, [500, 500])
print("Remaining Balance:", remaining_bal)


------------------------------------------------------------
Method 4: Using a decorator with **kwargs

# Using decorators with **kwargs
def calculate_decorator_kwargs(func):
    def wrapper(**kwargs):
        try:
            return func(**kwargs)
        except Exception as e:
            print(f"An error occurred: {e}")
            return None
    return wrapper

@calculate_decorator_kwargs
def calculate_remaining_balance_kwargs(salary, **expenses):
    total_expenses = sum(expenses.values())
    return salary - total_expenses

remaining_balance = calculate_remaining_balance_kwargs(salary=4000, rent=1200, groceries=300, miscellaneous=500)
print("Remaining balance using **kwargs decorator:", remaining_balance)

OR

def decorator_sum(func):
    def wrapper(**kwargs):
        # Extract salary and expenses from keyword arguments
        salary = kwargs.get("salary", 0)  # Default salary to 0 if not provided
        expenses = kwargs.get("expenses", [])  # Default expenses to an empty list
        
        # Calculate total expense
        total_expense = sum(expenses)
        
        # Pass processed arguments to the original function
        return func(salary=salary, total_expense=total_expense)
    return wrapper

@decorator_sum
def some_func(salary, total_expense):
    return salary - total_expense  # Subtract total expenses from salary

# Pass salary and expenses as keyword arguments
remaining_bal = some_func(salary=10000, expenses=[500, 500])
print("Remaining Balance (using kwargs):", remaining_bal)

-------------------------------------------------
Method 5: Using a decorator with *args


# Using decorators with *args
def calculate_decorator(func):
    def wrapper(*args):
        try:
            return func(*args)
        except Exception as e:
            print(f"An error occurred: {e}")
            return None
    return wrapper

@calculate_decorator
def calculate_remaining_balance(salary, *expenses):
    return salary - sum(expenses)

remaining_balance = calculate_remaining_balance(4000, 1200, 300, 500)
print("Remaining balance using *args decorator:", remaining_balance)

OR

def decorator_sum(func):
    def wrapper(*args):
        # Extract salary and expenses based on position
        salary = args[0]  # First argument is salary
        expenses = args[1]  # Second argument is a list of expenses
        
        # Calculate total expense
        total_expense = sum(expenses)
        
        # Pass processed arguments to the original function
        return func(salary, total_expense)
    return wrapper

@decorator_sum
def some_func(salary, total_expense):
    return salary - total_expense  # Subtract total expenses from salary

# Pass salary and expenses as positional arguments
remaining_bal = some_func(10000, [500, 500])
print("Remaining Balance (using args):", remaining_bal)

